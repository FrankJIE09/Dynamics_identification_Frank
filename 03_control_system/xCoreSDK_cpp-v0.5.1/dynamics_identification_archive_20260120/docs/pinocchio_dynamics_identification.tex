\documentclass[12pt,a4paper]{article}
\usepackage[UTF8]{ctex}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algorithmic}

\geometry{margin=2.5cm}

\title{Pinocchio 动力学与运动学参数辨识详解}
\author{基于 hybrid\_force\_position\_control.cpp 和 xCore SDK}
\date{\today}

\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    frame=single,
    breaklines=true,
    showspaces=false,
    showstringspaces=false,
    tabsize=2
}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{概述}

动力学参数辨识是机器人控制中的重要环节，通过实验数据估计机器人的动力学参数（质量、惯性、质心位置、摩擦系数等），以提高控制精度。本文档介绍如何使用 Pinocchio 库进行动力学参数辨识。

\section{动力学辨识的基本原理}

\subsection{线性参数化}

机器人动力学方程可以写成线性参数化的形式：

\begin{equation}
\boldsymbol{\tau} = \mathbf{Y}(\boldsymbol{q}, \dot{\boldsymbol{q}}, \ddot{\boldsymbol{q}}) \boldsymbol{\theta}
\label{eq:regressor}
\end{equation}

其中：
\begin{itemize}
    \item $\boldsymbol{\tau} \in \mathbb{R}^n$：关节力矩向量
    \item $\mathbf{Y}(\boldsymbol{q}, \dot{\boldsymbol{q}}, \ddot{\boldsymbol{q}}) \in \mathbb{R}^{n \times p}$：回归矩阵（Regressor Matrix）
    \item $\boldsymbol{\theta} \in \mathbb{R}^p$：待辨识的参数向量
    \item $n$：关节数量
    \item $p$：参数数量
\end{itemize}

\subsection{待辨识的参数}

对于每个连杆，需要辨识的参数包括：

\begin{enumerate}
    \item \textbf{质量：} $m_i$
    \item \textbf{质心位置：} $c_i = [c_{ix}, c_{iy}, c_{iz}]^T$
    \item \textbf{惯性张量：} $\mathbf{I}_i = \begin{bmatrix} I_{xx} & I_{xy} & I_{xz} \\ I_{xy} & I_{yy} & I_{yz} \\ I_{xz} & I_{yz} & I_{zz} \end{bmatrix}$
    \item \textbf{摩擦系数：} $f_{v,i}$（粘性摩擦）、$f_{c,i}$（库仑摩擦）
\end{enumerate}

\subsection{最小惯性参数集}

由于动力学方程中存在参数冗余，实际需要辨识的是最小惯性参数集（Minimum Inertial Parameters, MIP）。Pinocchio 可以自动计算最小参数集。

\section{Pinocchio 的辨识功能}

\subsection{核心函数}

Pinocchio 提供了以下关键函数用于动力学辨识：

\begin{lstlisting}[caption=Pinocchio 辨识相关函数]
// 1. 计算关节力矩回归矩阵
pinocchio::computeJointTorqueRegressor(
    model, data, q, dq, ddq, regressor);

// 2. 计算最小惯性参数集
pinocchio::computeMinimalInertialParameters(model);

// 3. 计算动能回归矩阵
pinocchio::computeKineticEnergyRegressor(model, data, q, dq);

// 4. 计算势能回归矩阵
pinocchio::computePotentialEnergyRegressor(model, data, q);
\end{lstlisting}

\subsection{回归矩阵的计算}

回归矩阵 $\mathbf{Y}$ 将动力学方程线性化，使得：

\begin{equation}
\boldsymbol{\tau} = \mathbf{Y}(\boldsymbol{q}, \dot{\boldsymbol{q}}, \ddot{\boldsymbol{q}}) \boldsymbol{\theta}
\end{equation}

其中每一行对应一个关节的力矩方程。

\section{辨识流程}

\subsection{步骤1：数据采集}

在机器人运动过程中，采集以下数据：

\begin{lstlisting}[caption=数据采集]
struct DataPoint {
    std::vector<double> q;      // 关节位置 (n维)
    std::vector<double> dq;     // 关节速度 (n维)
    std::vector<double> ddq;    // 关节加速度 (n维)
    std::vector<double> tau;    // 关节力矩 (n维，传感器测量)
    double timestamp;           // 时间戳
};

// 采集多个数据点
std::vector<DataPoint> collected_data;
\end{lstlisting}

\textbf{数据采集要求：}
\begin{itemize}
    \item 运动轨迹要能激励所有参数（Persistent Excitation）
    \item 覆盖机器人的工作空间
    \item 包含不同的速度和加速度组合
    \item 数据量要足够（通常需要数千个数据点）
\end{itemize}

\subsection{步骤2：构造回归方程}

对于每个数据点，构造回归方程：

\begin{lstlisting}[caption=构造回归方程]
// 初始化 Pinocchio 模型
pinocchio::Model model;
pinocchio::Data data(model);
pinocchio::urdf::buildModel(urdf_path, model);

// 计算最小惯性参数数量
int n_params = pinocchio::computeMinimalInertialParameters(model);

// 存储所有回归矩阵和力矩
Eigen::MatrixXd Y_all;  // 所有回归矩阵堆叠
Eigen::VectorXd tau_all; // 所有力矩堆叠

// 对每个数据点
for (const auto& point : collected_data) {
    // 转换为 Eigen 向量
    Eigen::VectorXd q = Eigen::Map<const Eigen::VectorXd>(
        point.q.data(), point.q.size());
    Eigen::VectorXd dq = Eigen::Map<const Eigen::VectorXd>(
        point.dq.data(), point.dq.size());
    Eigen::VectorXd ddq = Eigen::Map<const Eigen::VectorXd>(
        point.ddq.data(), point.ddq.size());
    
    // 计算回归矩阵
    Eigen::MatrixXd Y(n_joints, n_params);
    pinocchio::computeJointTorqueRegressor(
        model, data, q, dq, ddq, Y);
    
    // 堆叠到总矩阵
    Y_all.conservativeResize(Y_all.rows() + n_joints, n_params);
    Y_all.bottomRows(n_joints) = Y;
    
    // 堆叠力矩
    Eigen::VectorXd tau = Eigen::Map<const Eigen::VectorXd>(
        point.tau.data(), point.tau.size());
    tau_all.conservativeResize(tau_all.size() + n_joints);
    tau_all.tail(n_joints) = tau;
}
\end{lstlisting}

\subsection{步骤3：求解参数}

使用最小二乘法求解参数：

\begin{equation}
\hat{\boldsymbol{\theta}} = (\mathbf{Y}^T \mathbf{Y})^{-1} \mathbf{Y}^T \boldsymbol{\tau}
\label{eq:least_squares}
\end{equation}

\begin{lstlisting}[caption=最小二乘求解]
// 求解参数
Eigen::VectorXd theta_estimated = 
    (Y_all.transpose() * Y_all).ldlt().solve(
        Y_all.transpose() * tau_all);

// 或者使用 SVD（更稳定）
Eigen::JacobiSVD<Eigen::MatrixXd> svd(
    Y_all, Eigen::ComputeThinU | Eigen::ComputeThinV);
Eigen::VectorXd theta_estimated = 
    svd.solve(tau_all);
\end{lstlisting}

\subsection{步骤4：添加物理约束}

为了确保辨识的参数具有物理意义，需要添加约束：

\begin{enumerate}
    \item \textbf{质量为正：} $m_i > 0$
    \item \textbf{惯性矩阵正定：} $\mathbf{I}_i \succ 0$
    \item \textbf{摩擦系数非负：} $f_{v,i} \geq 0, f_{c,i} \geq 0$
\end{enumerate}

\begin{lstlisting}[caption=带约束的优化]
// 使用带约束的优化求解器（如 Ceres, Ipopt 等）
// 目标函数：最小化 ||Y * theta - tau||^2
// 约束：物理约束
\end{lstlisting}

\subsection{步骤5：验证结果}

使用未参与训练的数据验证辨识结果：

\begin{lstlisting}[caption=验证辨识结果]
// 使用辨识的参数计算预测力矩
Eigen::VectorXd tau_predicted = Y_test * theta_estimated;

// 计算误差
Eigen::VectorXd error = tau_measured - tau_predicted;
double rmse = std::sqrt(error.squaredNorm() / error.size());

std::cout << "RMSE: " << rmse << " Nm" << std::endl;
std::cout << "最大误差: " << error.cwiseAbs().maxCoeff() << " Nm" << std::endl;
\end{lstlisting}

\section{激励轨迹设计}

\subsection{Persistent Excitation 条件}

为了能够辨识所有参数，激励轨迹必须满足 Persistent Excitation 条件：

\begin{equation}
\exists T, \alpha > 0: \quad \frac{1}{T} \int_0^T \mathbf{Y}^T(t) \mathbf{Y}(t) dt \succeq \alpha \mathbf{I}
\end{equation}

即回归矩阵的积分必须正定。

\subsection{常用激励轨迹}

\subsubsection{1. 正弦轨迹}

\begin{equation}
q_i(t) = q_{i,0} + A_i \sin(\omega_i t + \phi_i)
\end{equation}

其中 $A_i$ 是幅值，$\omega_i$ 是频率，$\phi_i$ 是相位。

\subsubsection{2. 傅里叶级数轨迹}

\begin{equation}
q_i(t) = q_{i,0} + \sum_{k=1}^{N} \frac{A_{i,k}}{k \omega} \sin(k \omega t) - \frac{B_{i,k}}{k \omega} \cos(k \omega t)
\end{equation}

\subsubsection{3. 多项式轨迹}

\begin{equation}
q_i(t) = \sum_{k=0}^{N} a_{i,k} t^k
\end{equation}

\section{单臂系统辨识}

\subsection{代码示例}

\begin{lstlisting}[caption=单臂系统辨识示例]
#include <pinocchio/pinocchio.hpp>
#include <pinocchio/parsers/urdf.hpp>
#include <Eigen/Dense>

void identifySingleArmDynamics(
    const std::string& urdf_path,
    const std::vector<DataPoint>& data) {
    
    // 1. 加载模型
    pinocchio::Model model;
    pinocchio::Data data_pin(model);
    pinocchio::urdf::buildModel(urdf_path, model);
    
    int n_joints = model.nv;  // 7个关节
    int n_params = pinocchio::computeMinimalInertialParameters(model);
    
    std::cout << "关节数: " << n_joints << std::endl;
    std::cout << "参数数: " << n_params << std::endl;
    
    // 2. 构造回归矩阵
    Eigen::MatrixXd Y_all;
    Eigen::VectorXd tau_all;
    
    for (const auto& point : data) {
        Eigen::VectorXd q(7), dq(7), ddq(7), tau(7);
        // ... 填充数据 ...
        
        Eigen::MatrixXd Y(7, n_params);
        pinocchio::computeJointTorqueRegressor(
            model, data_pin, q, dq, ddq, Y);
        
        // 堆叠
        if (Y_all.rows() == 0) {
            Y_all = Y;
            tau_all = tau;
        } else {
            Eigen::MatrixXd Y_new(Y_all.rows() + 7, n_params);
            Y_new << Y_all, Y;
            Y_all = Y_new;
            
            Eigen::VectorXd tau_new(tau_all.size() + 7);
            tau_new << tau_all, tau;
            tau_all = tau_new;
        }
    }
    
    // 3. 求解参数
    Eigen::JacobiSVD<Eigen::MatrixXd> svd(
        Y_all, Eigen::ComputeThinU | Eigen::ComputeThinV);
    Eigen::VectorXd theta = svd.solve(tau_all);
    
    // 4. 更新模型参数
    // 注意：需要将 theta 映射回模型的惯性参数
    // 这需要根据最小参数集的定义进行转换
    
    std::cout << "辨识完成！" << std::endl;
}
\end{lstlisting}

\section{双臂系统辨识}

\subsection{特殊考虑}

对于双臂系统，需要注意：

\begin{enumerate}
    \item \textbf{耦合效应：} 两个手臂通过基座耦合，需要同时激励两个手臂
    \item \textbf{参数数量：} 参数数量是单臂的两倍（如果两条臂相同）
    \item \textbf{数据量：} 需要更多的数据点来辨识耦合参数
\end{enumerate}

\subsection{代码示例}

\begin{lstlisting}[caption=双臂系统辨识]
void identifyDualArmDynamics(
    const std::string& urdf_path,
    const std::vector<DataPoint>& data) {
    
    pinocchio::Model model;
    pinocchio::Data data_pin(model);
    pinocchio::urdf::buildModel(urdf_path, model);
    
    int n_joints = model.nv;  // 14个关节（假设每条臂7个）
    int n_params = pinocchio::computeMinimalInertialParameters(model);
    
    // 构造回归矩阵（与单臂类似，但维度为14）
    Eigen::MatrixXd Y_all;
    Eigen::VectorXd tau_all;
    
    for (const auto& point : data) {
        Eigen::VectorXd q(14), dq(14), ddq(14), tau(14);
        // ... 填充数据 ...
        
        Eigen::MatrixXd Y(14, n_params);
        pinocchio::computeJointTorqueRegressor(
            model, data_pin, q, dq, ddq, Y);
        
        // 堆叠（与单臂相同）
        // ...
    }
    
    // 求解参数
    Eigen::VectorXd theta = solveLeastSquares(Y_all, tau_all);
}
\end{lstlisting}

\section{全身系统辨识}

\subsection{包含底盘和腰部的辨识}

对于全身系统（包括底盘、腰部、双臂），辨识过程更复杂：

\begin{enumerate}
    \item \textbf{浮动基座：} 如果底盘是浮动的，需要额外考虑基座的运动
    \item \textbf{腰部关节：} 折叠和旋转关节的参数需要单独辨识
    \item \textbf{耦合参数：} 需要辨识底盘-腰部、腰部-手臂之间的耦合参数
\end{enumerate}

\subsection{数据采集策略}

\begin{lstlisting}[caption=全身系统数据采集]
// 1. 固定底盘，只运动腰部
// 2. 固定腰部，只运动手臂
// 3. 同时运动所有关节（用于辨识耦合参数）

// 设计不同的激励轨迹
std::vector<Trajectory> trajectories = {
    baseOnlyTrajectory(),      // 只运动底盘
    torsoOnlyTrajectory(),     // 只运动腰部
    armsOnlyTrajectory(),      // 只运动手臂
    fullBodyTrajectory()       // 全身运动
};
\end{lstlisting}

\section{摩擦参数辨识}

\subsection{摩擦模型}

常用的摩擦模型包括：

\begin{equation}
\tau_f = f_v \dot{q} + f_c \text{sign}(\dot{q})
\end{equation}

其中 $f_v$ 是粘性摩擦系数，$f_c$ 是库仑摩擦系数。

\subsection{辨识方法}

\begin{lstlisting}[caption=摩擦参数辨识]
// 方法1：低速运动（主要激励库仑摩擦）
for (double speed = 0.01; speed < 0.1; speed += 0.01) {
    // 以恒定低速运动，测量力矩
    // 力矩 = 重力 + 库仑摩擦
}

// 方法2：不同速度运动（辨识粘性摩擦）
for (double speed = 0.1; speed < 1.0; speed += 0.1) {
    // 以不同速度运动
    // 力矩 = 重力 + 粘性摩擦 * 速度 + 库仑摩擦
}

// 使用线性回归求解摩擦系数
Eigen::MatrixXd Y_friction(n_points, 2);
Eigen::VectorXd tau_friction(n_points);

// Y_friction 的列：[速度, sign(速度)]
// tau_friction: 测量的摩擦力矩

Eigen::Vector2d friction_params = 
    Y_friction.colPivHouseholderQr().solve(tau_friction);
// friction_params[0]: f_v (粘性摩擦)
// friction_params[1]: f_c (库仑摩擦)
\end{lstlisting}

\section{实际应用中的注意事项}

\subsection{数据质量}

\begin{itemize}
    \item \textbf{传感器校准：} 确保力矩传感器准确校准
    \item \textbf{噪声处理：} 使用滤波减少测量噪声
    \item \textbf{同步问题：} 确保位置、速度、加速度、力矩数据时间同步
\end{itemize}

\subsection{加速度估计}

关节加速度通常无法直接测量，需要通过数值微分估计：

\begin{lstlisting}[caption=加速度估计]
// 方法1：数值微分
Eigen::VectorXd ddq = (dq_current - dq_previous) / dt;

// 方法2：Kalman滤波
// 使用状态估计器同时估计速度和加速度

// 方法3：频域滤波
// 使用低通滤波减少噪声
\end{lstlisting}

\subsection{参数验证}

\begin{enumerate}
    \item \textbf{物理合理性：} 检查质量、惯性是否在合理范围内
    \item \textbf{交叉验证：} 使用未参与训练的数据验证
    \item \textbf{误差分析：} 分析误差分布，找出辨识不好的参数
\end{enumerate}

\section{完整辨识流程示例}

\begin{algorithm}
\caption{动力学参数辨识完整流程}
\begin{algorithmic}[1]
\REQUIRE URDF模型文件、数据采集系统
\ENSURE 辨识的动力学参数
\STATE 加载URDF模型，初始化Pinocchio
\STATE 计算最小惯性参数集
\STATE 设计激励轨迹（满足PE条件）
\STATE \textbf{for} 每个轨迹 \textbf{do}
    \STATE 执行轨迹，采集数据（q, dq, ddq, tau）
\STATE \textbf{end for}
\STATE 构造回归矩阵 Y 和力矩向量 tau
\STATE 求解参数：$\theta = (Y^T Y)^{-1} Y^T \tau$
\STATE 添加物理约束，优化参数
\STATE 使用验证数据评估辨识精度
\STATE \textbf{if} 精度不满足要求 \textbf{then}
    \STATE 调整激励轨迹，重新采集数据
\STATE \textbf{end if}
\STATE 更新URDF模型中的参数
\end{algorithmic}
\end{algorithm}

\section{与 xCore SDK 集成}

\subsection{数据采集}

在 \texttt{hybrid\_force\_position\_control.cpp} 中，可以添加数据采集功能：

\begin{lstlisting}[caption=在控制循环中采集数据]
std::function<Torque(void)> callback = [&]{
    // 获取状态
    std::array<double, 7> q{}, dq_m{}, ddq_c{}, tau_m_measured{};
    robot.getStateData(jointPos_m, q);
    robot.getStateData(jointVel_m, dq_m);
    robot.getStateData(jointAcc_c, ddq_c);
    robot.getStateData(tau_m, tau_m_measured);
    
    // 保存数据点（用于辨识）
    if (collecting_data) {
        DataPoint point;
        point.q = std::vector<double>(q.begin(), q.end());
        point.dq = std::vector<double>(dq_m.begin(), dq_m.end());
        point.ddq = std::vector<double>(ddq_c.begin(), ddq_c.end());
        point.tau = std::vector<double>(tau_m_measured.begin(), 
                                        tau_m_measured.end());
        collected_data.push_back(point);
    }
    
    // ... 控制逻辑 ...
};
\end{lstlisting}

\subsection{辨识后更新模型}

\begin{lstlisting}[caption=更新模型参数]
// 辨识完成后，更新 Pinocchio 模型
void updateModelParameters(
    pinocchio::Model& model,
    const Eigen::VectorXd& theta_identified) {
    
    // 将辨识的参数映射回模型的惯性参数
    // 这需要根据最小参数集的定义进行逆映射
    
    int param_idx = 0;
    for (pinocchio::JointIndex i = 1; i < model.njoints; ++i) {
        // 更新每个关节的惯性参数
        // model.inertias[i] = ...
    }
}
\end{lstlisting}

\section{总结}

\begin{itemize}
    \item \textbf{Pinocchio 支持动力学辨识：} 提供了回归矩阵计算、最小参数集等关键功能
    \item \textbf{线性参数化：} 动力学方程可以写成线性形式，便于求解
    \item \textbf{激励轨迹设计：} 必须满足 Persistent Excitation 条件
    \item \textbf{数据质量重要：} 准确的传感器数据和同步是关键
    \item \textbf{适用于复杂系统：} 单臂、双臂、全身系统都可以使用相同的方法
    \item \textbf{需要验证：} 辨识结果必须通过验证数据检验
\end{itemize}

\section{参考文献}

\begin{enumerate}
    \item Pinocchio Documentation: \url{https://stack-of-tasks.github.io/pinocchio/}
    \item Swevers, J., et al. (1997). "Optimal robot excitation and identification." \textit{IEEE Transactions on Robotics and Automation}, 13(5), 730-740.
    \item Gautier, M., and Khalil, W. (1992). "Direct calculation of minimum set of inertial parameters of serial robots." \textit{IEEE Transactions on Robotics and Automation}, 8(3), 368-373.
    \item Featherstone, R. (2008). \textit{Rigid Body Dynamics Algorithms}. Springer.
    \item \texttt{hybrid\_force\_position\_control.cpp} - ROKAE xCore SDK 示例代码
\end{enumerate}

\end{document}

